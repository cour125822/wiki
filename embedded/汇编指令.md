---
title: 汇编指令
description: 
published: true
date: 2023-03-26T08:03:14.697Z
tags: 
editor: markdown
dateCreated: 2023-03-26T07:47:25.497Z
---

# 指令
> 指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。

## 数据处理指令
- 数据传输指令	mov mvn
- 算术指令		add sub rsb adc sbc rsc 
- 逻辑指令		and orr eor bic
- 比较指令		cmp cmn tst teq
- 乘法指令		mvl mla umull umlal smull smlal
- 前导零计数		clz

## cpsr访问指令
`mrs & msr`
- mrs用来读psr
- msr用来写psr
CPSR寄存器比较特殊，需要专门的指令访问，这就是`mrs`和`msr`。

## 跳转(分支)指令
`b & bl & bx`

- `b` 直接跳转（就没打开算返回）
- `bl` branch and link，跳转前把返回地址放入lr中，以便返回，以便用于函数调用
- `bx`跳转同时切换到ARM模式，一般用于异常处理的跳转。

## 访存指令
`ldr/str &	ldm/stm & swp`

- 单个字/半字/字节访问 ldr/str
- 多字批量访问  ldm(load register mutiple) / stm（store register mutiple）
- `swp r1, r2, [r0]`
-` swp r1, r1, [r0]`

ldr/str每周期只能访问4字节内存，如果需要批量读取、写入内存时太慢，解决方案是stm/ldm

`stmia	sp, {r0 - r12}`将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入该地址；然后地址再+4（指向0x30001008），将r2存入该地址······直到r12内容放入（0x3001030），指令完成。
## 四种栈
- 空栈：栈指针指向空位，每次存入时可以直接存入然后栈指针移动一格；而取出时需要先移动一格才能取出
- 满栈：栈指针指向栈中最后一格数据，每次存入时需要先移动栈指针一格再存入；取出时可以直接取出，然后再移动栈指针
- 增栈：栈指针移动时向地址增加的方向移动的栈
- 减栈：栈指针移动时向地址减小的方向移动的栈



## 8种后缀
- ia（increase after）先传输，再地址+4
- ib（increase before）先地址+4，再传输
- da（decrease after）先传输，再地址-4
- db（decrease before）先地址-4，再传输
- fd（full decrease）满递减堆栈
- ed（empty decrease）空递减堆栈
- fa（·······） 满递增堆栈
- ea（·······）空递增堆栈

## ！的作用
感叹号的作用就是r0的值在ldm过程中发生的增加或者减少最后写回到r0去，也就是说ldm时会改变r0的值
```S
ldmia	r0, {r2 - r3}
ldmia	r0！, {r2 - r3}

```

## ^的作用

^的作用：在目标寄存器中有pc时，会同时将spsr写入到cpsr，一般用于从异常模式返回。

```
ldmfd	sp!, {r0 - r6, pc}
ldmfd	sp!, {r0 - r6, pc}^
```




## 立即数
### 合法立即数
经过任意位数的移位后非零部分可以用8位表示的即为合法立即数

### 非法立即数

## 软中断指令
`swi（software interrupt）`
软中断指令用来实现操作系统中系统调用

## 协处理器
SoC内部另一处理核心，协助主CPU实现某些功能，被主CPU调用执行一定任务。
ARM设计上支持多达16个协处理器，但是一般SoC只实现其中的CP15.（cp：coprocessor）
协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关。

`mcr & mrc`

- mrc用于读取CP15中的寄存器
- mcr用于写入CP15中的寄存器
### MRC & MCR的使用方法
```S
mcr{<cond>}   p15, <opcode_1>, <Rd>, <Crn>, <Crm>, {<opcode_2>}
```
- opcode_1：对于cp15永远为0
- Rd：ARM的普通寄存器
- Crn：cp15的寄存器，合法值是c0～c15
- Crm：cp15的寄存器，一般均设为c0
- opcode_2：一般省略或为0



# 伪指令
> 伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。

## 常见符号
- `@` 用来做注释。可以在行首也可以在代码后面同一行直接跟，和C语言中//类似
- `#` 做注释，一般放在行首，表示这一行都是注释而不是代码。
- `：`以冒号结尾的是标号
- `. ` 点号在gnu汇编中表示当前指令的地址
- `#` 立即数前面要加#或$，表示这是个立即数

## 常见伪指令
- `.global _start`		@ 给_start外部链接属性
- `.section .text	`	@ 指定当前段为代码段
- `.ascii .byte .short .long .word `
- `.quad .float .string` @ 定义数据
- `.align 4`			@ 以16字节对齐
- `.balignl 16 0xabcdefgh` 	@ 16字节对齐填充
- `.equ	`		@ 类似于C中宏定义
- `.end`			@标识文件结束
- `.include	`		@ 头文件包含
- `.arm / .code32`	@声明以下为arm指令
- `.thumb / .code16`	@声明以下为thubm指令

## 重要伪指令
- ldr		大范围的地址加载指令
- adr	小范围的地址加载指令
- adrl	中等范围的地址加载指令
- nop	空操作

说明：
- ARM中有一个ldr指令，还有一个ldr伪指令，一般都使用ldr伪指令而不用ldr指令
- adr编译时会被1条sub或add指令替代，而ldr编译时会被一条mov指令替代或者文字池方式处理；
- adr总是以PC为基准来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址在哪里
- ldr加载的地址和链接时给定的地址有关，由链接脚本决定。







# ARM汇编特点
## LDR/STR架构
- ARM采用RISC架构，CPU本身不能直接读取内存，而需要先将内存中内容加载入CPU中通用寄存器中才能被CPU处理。
- ldr（load register）指令将内存内容加载入通用寄存器。
- str（store register）指令将寄存器内容存入内存空间中。
- ldr/str组合用来实现 ARM CPU和内存数据交换

## 8种寻址方式
- 寄存器寻址                  `mov r1, r2`
- 立即寻址			`mov r0, #0xFF00`
- 寄存器移位寻址		`mov r0, r1, lsl #3`
- 寄存器间接寻址		`ldr r1, [r2]`
- 基址变址寻址		`ldr r1, [r2, #4]`
- 多寄存器寻址		`ldmia r1!, {r2-r7, r12}`
- 堆栈寻址			`stmfd sp!, {r2-r7, lr}`
- 相对寻址		       `beq flag`


## 指令后缀
同一指令经常附带不同后缀，变成不同的指令。

**经常使用的后缀有：**
- B（byte）功能不变，操作长度变为8位
- H（half word）功能不变，长度变为16位
- S（signed）功能不变，操作数变为有符号
	如 `ldr` `ldrb` `ldrh` `ldrsb` `ldrsh`
- S（S标志）功能不变，影响CPSR标志位
	如 `mov和movs`		`movs r0, #0`


## 条件执行后缀
| 操作码 | 条件助记符 | 标志     | 含义                       |
|:------ |:---------- |:-------- |:-------------------------- |
| 0000   | EQ         | Z=1      | 相等                       |
| 0001   | NE         | Z=0      | 不相等                     |
| 0010   | CS/HS      | C=1      | 无符号数大于或等于         |
| 0011   | CC/LO      | C=0      | 无符号数小于               |
| 0100   | MI         | N=1      | 负数                       |
| 0101   | PL         | N=0      | 正数或零                   |
| 0110   | VS         | V=1      | 溢出                       |
| 0111   | VC         | V=0      | 没有溢出                   |
| 1000   | HI         | C=1,Z=0  | 无符号数大于               |
| 1001   | LS         | C=0,Z=1  | 无符号数小于或等于         |
| 1010   | GE         | N=V      | 有符号数小于或等于         |
| 1011   | LT         | N!=V     | 有符号数小于于             |
| 1100   | GT         | Z=0,N=V  | 有符号数大于               |
| 1101   | LE         | Z=1,N!=V | 有符号数小于或等于         |
| 1110   | AL         | 任意     | 无条件执行（指令默认条件） |
| 1111   | NV         | 任意     | 从不执行                   |

## 多级指令流水线
> 允许多个操作同时处理，而非顺序执行。

为增加处理器指令流的速度，ARM使用多级流水线.，下图为3级流水线工作原理示意图。（S5PV210使用13级流水线，ARM11为8级）
![image.png](https://raw.githubusercontent.com/cour125822/photo_wi/main/wiki/202304081656347.png)
PC指向正被取指的指令，而非正在执行的指令


### 3级流水线
1. 取指令（Fetch）：从寄存器装载一条指令。
2. 译码（Decode）：识别被执行的指令，并为下一个周期准备数据通路的控制信号。在这一级，指令占有译码逻辑，不占用数据通路。
3. 执行（Excute）：处理指令并将结果写回寄存器。
![image.png](https://raw.githubusercontent.com/cour125822/photo_wi/main/wiki/202304081659206.png)

所有的处理器都要满足对高性能的要求，直到 ARM7 为止，在 ARM 核中使用的 3 级流水线的性价比是很高的。但是，为了得到更高的性能，需要重新考虑处理器的组织结构。有两种方法来提高性能。
1. 提高时钟频率。时钟频率的提高，必然引起指令执行周期的缩短，所以要求简化流水线每一级的逻辑，流水线的级数就要增加。
2. 减少每条指令的平均指令周期数 CPI。这就要求重新考虑 3 级流水线 ARM 中多于 1 个流水线周期的实现方法，以便使其占有较少的周期，或者减少因指令相关造成的流水线停顿，也可以将两者结合起来。

### 5 级流水线
1. 取指令（Fetch）：从存储器中取出指令，并将其放入指令流水线。
2. 译码（Decode）：指令被译码，从寄存器堆中读取寄存器操作数。在寄存器堆有 3 个操作数读端口，因此，大多数 ARM 指令能在1 个周期内读取其操作数。
3. 执行（Execute）：将其中 1 个操作数移位，并在 ALU 中产生结果。如果指令是Load 或 Store 指令，则在 ALU 中计算存储器的地址。
4. 缓冲/数据（Buffer/Data）：如果需要则访问数据存储器，否则 ALU 只是简单地缓冲 1 个时钟周期。
5. 回写（Write-Back）：将指令的结果回写到寄存器堆，包括任何从寄存器读出的数据 ![image.png](https://raw.githubusercontent.com/cour125822/photo_wi/main/wiki/202304081702130.png)
PC 值是基于 3 级流水线操作特性的。5 级流水线中提前 1 级来读取指令操作数，得到的值是不同的（PC + 4 而不是PC + 8）。


### 13级流水线

在 Cortex-A8 中有一条 13 级的流水线，但是由于 ARM 公司没有对其中的技术公开任何相关的细节，这里只能简单介绍一下，从经典ARM 系列到现在的 Cortex 系列，ARM 处理器的结构在向复杂的阶段发展，但没改变的是 CPU 的取指指令和地址关系，不管是几级流水线，都可以按照最初的 3 级流水线的操作特性来判断其当前的 PC 位置。这样做主要还是为了软件兼容性上的考虑，由此可以判断的是，后面 ARM 所推出的处理核心都想满足这一特点

### 流水线性能影响
1. 互锁
	在典型的程序处理过程中，经常会遇到这样的情形，即一条指令的结果被用作下一条指令的操作数。例如，有如下指令序列：
	```s
	LDR R0,[R0,#0]
	ADD R0,R0,R1 ;在 5 级流水线上产生互锁
	```
	从例子可以看出，流水线的操作产生中断，因为第 1 条指令的结果在第 2 条指令取数时还没有产生。第 2 条指令必须停止，直到结果产生为止。
2. 跳转指令
	跳转指令也会破坏流水线的行为，因为后续指令的取指步骤受到跳转目标计算的影响，因而必须推迟。但是，当跳转指令被译码时，在它被确认是跳转指令之前，后续的取指操作已经发生。这样一来，已经被预取进入流水线的指令不得不被丢弃。如果跳转目标的计算是在ALU 阶段完成的，那么在得到跳转目标之前已经有两条指令按原有指令流读取。显然，只有当所有指令都依照相似的步骤执行时，流水线的效率达到最高。如果处理器的指令非常复杂，每一条指令的行为都与下一条指令不同，那么就很难用流水线实现。


