---
title: 作用域
description: 
published: true
date: 2023-03-26T08:08:48.839Z
tags: 
editor: markdown
dateCreated: 2023-02-26T04:42:45.747Z
---

# 全局作用域与局部作用域

按照名字作用范围的不同可以将三个名称空间划分为两个区域：

1. 全局作用域:位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）；
2. 局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）。

# 作用域与名字查找的优先级

在局部作用域查找名字时，起始位置是局部作用域，所以先查找局部名称空间，没有找到，再去全局作用域查找：先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常

```py
x=100 #全局作用域的名字x 
def foo():     
	x=300 #局部作用域的名字x     
  print(x) #在局部找x foo()
  #结果为300
```

在全局作用域查找名字时，起始位置便是全局作用域，所以先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常

```py
x=100 
def foo():     
	x=300 #在函数调用时产生局部作用域的名字x 
foo() 
print(x) #在全局找x,结果为100
```

> 可以调用内建函数locals()和globals()来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals()的结果等于globals()
{.is-info}


Python支持函数的嵌套定义，在内嵌的函数内查找名字时，会优先查找自己局部作用域的名字，然后由内而外一层层查找外部嵌套函数定义的作用域，没有找到，则查找全局作用域

```py
x=1 
def outer():     
	x=2     
def inner(): # 函数名inner属于outer这一层作用域的名字         
	x=3      
	print('inner x:%s' %x)  
inner()   
print('outer x:%s' %x) 
outer()  #结果为 inner x:3 outer x:2
```

在函数内，无论嵌套多少层，都可以查看到全局作用域的名字，若要在函数内修改全局名称空间中名字的值，当值为不可变类型时，则需要用到global关键字

```py
x=1 
def foo():    
	global x #声明x为全局名称空间的名字   
	x=2
foo() 
print(x) #结果为2
```

当实参的值为可变类型时，函数体内对该值的修改将直接反应到原值，

```py
num_list=[1,2,3] 
def foo(nums):  
	nums.append(5) 
foo(num_list)
print(num_list) #结果为 [1, 2, 3, 5]
```

对于嵌套多层的函数，使用nonlocal关键字可以将名字声明为来自外部嵌套函数定义的作用域（非全局）

```py
def  f1():    
	x=2     
	def f2():     
		nonlocal x      
		x=3    
	f2() #调用f2(),修改f1作用域中名字x的值  
	print(x) #在f1作用域查看x
f1() #结果 3 
```

nonlocal x会从当前函数的外层函数开始一层层去查找名字x，若是一直到最外层函数都找不到，则会抛出异常。