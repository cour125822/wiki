---
title: 内存管理
description: 
published: true
date: 2023-03-26T08:04:56.315Z
tags: 
editor: markdown
dateCreated: 2023-02-26T04:33:23.706Z
---

> 垃圾回收机制： 简称（GC），是 python 自带的一种机制，专门用来处理回收内存中的无用数据所占用的内存空间
{.is-info}


程序运行过程中会申请大量的内存空间，而对于一些无用的内存空间如果不及时清理的话会导致内存使用殆尽（内存溢出），导致程序崩溃，因此管理内存是一件重要且繁杂的事情，而 python 解释器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来

# 回收机制原理

Python 的 GC 模块主要运用了“ **引用计数** ”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，并且通过“ **分代回收** ”（generation collection）以空间换取时间的方式来进一步提高垃圾回收的效率。

## 引用计数

指的是变量被变量名关联次数

关联一次，引用计数加一，变量值被关联次数的增加或减少，都会引发引用计数机制的执行（增加或减少值的引用计数），这存在明显的效率问题。

如果说执行效率还仅仅是引用计数机制的一个软肋的话，那么很不幸，引用计数机制还存在着一个致命的弱点，即循环引用（也称交叉引用）

## 标记清除

关于变量的存储，内存中有两块区域：堆区与栈区，在定义变量时，变量名与值内存地址的关联关系存放于栈区，变量值存放于堆区，内存管理回收的则是堆区的内容。

*1、标记* 通俗地讲就是：标记的过程就行相当于从栈区出发一条线，“连接”到堆区，再由堆区间接“连接”到其他地址，凡是被这条自栈区起始的线连接到内存空间都属于可以访达的，会被标记为存活 具体地：标记的过程其实就是，遍历所有的 GC Roots 对象(栈区中的所有内容或者线程都可以作为 GC Roots 对象），然后将所有 GC Roots 的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。 *#2、清除* 清除的过程将遍历堆中所有的对象，将没有标记存活的对象全部清除掉。

## 分代回收

分代指的是根据存活时间来为变量划分不同等级（也就是不同的代） 新定义的变量，放到新生代这个等级中，假设每隔 1 分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为 3），会将它移动到更高一级的青春代，青春代的 gc 扫描的频率低于新生代（扫描时间间隔更长），假设 5 分钟扫描青春代一次，这样每次 gc 需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低

存在回收延迟问题

‍