---
title: 进程
description: 
published: true
date: 2023-03-26T08:04:23.747Z
tags: 
editor: markdown
dateCreated: 2023-02-26T06:44:39.835Z
---

# 介绍
# 进程

## 计算机多程序运行方式

进程是操作系统上的概念，操作系统将cpu资源进行调度

### 多道技术

对于单核心的情况下，当有一个进程进行IO操作的时候不再需要占用CPU资源，将CPU的占用状态解除，让其他进程来使用，在io操作结束后能够恢复到切换前的状态，解决程序的io阻塞

## 进程介绍

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是[操作系统](https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192)结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。

广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的[基本单元](https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83/10276)，在传统的操作系统中，进程既是基本的[分配单元](https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83)，也是基本的执行单元。

1. 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。
2. 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。

进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。

从理论角度看，是对正在运行的程序过程的抽象；

从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。

### 进程的特征

* 动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
* 并发性：任何进程都可以同其他进程一起并发执行
* 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；
* 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进
* 结构特征：进程由程序、数据和进程控制块三部分组成。

多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。

### 进程与程序中的区别

程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。

程序可以作为一种软件资料长期存在，而进程是有一定生命期的。

程序是永久的，进程是暂时的。

注意：**同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。**

## 进程调度

要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。

### 先来先服务调度算法

先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。

### 短作业优先调度算法

短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。

### 时间片轮转法

时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例。在时间片轮转法中，需要将CPU的处理时间分成固定大小的时间片，例如，几十毫秒至几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但又未完成要求的任务，则它自行释放自己所占有的CPU而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。

显然，轮转法只能用来调度分配一些可以抢占的资源。这些可以抢占的资源可以随时被剥夺，而且可以将它们再分配给别的进程。CPU是可抢占资源的一种。但打印机等资源是不可抢占的。由于作业调度是对除了CPU之外的所有系统硬件资源的分配，其中包含有不可抢占资源，所以作业调度不使用轮转法。

在轮转法中，时间片长度的选取非常重要。首先，时间片长度的选择会直接影响到系统的开销和响应时间。如果时间片长度过短，则调度程序抢占处理机的次数增多。这将使进程上下文切换次数也大大增加，从而加重系统开销。反过来，如果时间片长度选择过长，例如，一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕，则轮转法变成了先来先服务法。时间片长度的选择是根据系统对响应时间的要求和就绪队列中所允许最大的进程数来确定的。

在轮转法中，加入到就绪队列的进程有3种情况：

1. 第一种是分给它的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度去继续执行。
2. 第二种情况是分给该进程的时间片并未用完，只是因为请求I/O或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。
3. 第三种情况就是新创建进程进入就绪队列。

如果对这些进程区别对待，给予不同的优先级和时间片从直观上看，可以进一步改善系统服务质量和效率。例如，我们可把就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列，每个队列按FCFS原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同。这样，当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。

### 多级反馈队列

前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。

而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。

1. 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。
2. 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。
3. 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。

## 几个概念

### 并发与并行

**并行:** 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）

**并发:** 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。

并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。

并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。

### 进程状态

在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。

1. 就绪(Ready)状态：当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。
2. 执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。
3. 阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。

### 异步与同步

所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。

所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。

### 阻塞与非阻塞

阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的

注意：**同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。**

### 组合

### **同步阻塞形式**

效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。

### **异步阻塞形式**

如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面。

异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。

### **同步非阻塞形式**

实际上是效率低下的。

想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。

### **异步非阻塞形式**

效率更高，

因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。

比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。

很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。

[创建进程](https://www.notion.so/b283acfda68d410a8986029ba8876859)

[进程锁](https://www.notion.so/a7a245fa914e4bf3bfd533f704dd38c3)

[进程间通信](https://www.notion.so/d6460d9e4def4d36a5c307019cf6b00b)



# 创建进程
# multiprocess模块

仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。

# multiprocess.process模块

process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。

# process模块介绍

`Process([group [, target [, name [, args [, kwargs]]]]])`，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）

强调：

1. 需要使用关键字的方式来指定参数
2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号

参数介绍：

* group参数未使用，值始终为None
* target表示调用对象，即子进程要执行的任务
* args表示调用对象的位置参数元组，`args=(1,2,'egon',)`
* kwargs表示调用对象的字典，`kwargs={'name':'egon','age':18}`
* name为子进程的名称

## 方法介绍

* `p.start()`：启动进程，并调用该子进程中的p.run()
* `p.run()`：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法
* `p.terminate()`：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁
* `p.is_alive()`：如果p仍然运行，返回True
* `p.join([timeout])`：主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程

## 属性介绍

* `p.daemon`：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在`p.start()`之前设置
* `p.name`：进程的名称
* `p.pid`：进程的pid
* `p.exitcode`：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)
* `p.authkey`：进程的身份验证键,默认是由`os.urandom()`随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）

## 在windows中使用process模块的注意事项

在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用`if \\_\\_name\\_\\_ =='\\_\\_main\\_\\_'` 判断保护起来，import 的时候，就不会递归运行了。

# 使用process模块创建进程

在一个python进程中开启子进程，start方法和并发效果。

## 在Python中启动的第一个子进程

`import time from multiprocessing import Process def f(name):     print('hello', name)     print('我是子进程') if __name__ == '__main__':     p = Process(target=f, args=('bob',))     p.start()     time.sleep(1)     print('执行主进程的内容了')`

## join方法

`import time from multiprocessing import Process def f(name):     print('hello', name)     time.sleep(1)     print('我是子进程') if __name__ == '__main__':     p = Process(target=f, args=('bob',))     p.start()     # p.join()     print('我是父进程')`

## 查看主进程和子进程的进程号

`import os from multiprocessing import Process def f(x):     print('子进程id ：',os.getpid(),'父进程id ：',os.getppid())     return x*x if __name__ == '__main__':     print('主进程id ：', os.getpid())     p_lst = []     for i in range(5):         p = Process(target=f, args=(i,))         p.start()`

进阶，多个进程同时运行（注意，子进程的执行顺序不是根据启动顺序决定的）

## 多个进程同时运行

`import time from multiprocessing import Process def f(name):     print('hello', name)     time.sleep(1) if __name__ == '__main__':     p_lst = []     for i in range(5):         p = Process(target=f, args=('bob',))         p.start()         p_lst.append(p)`

## 多个进程同时运行，再谈join方法(1)

`import time from multiprocessing import Process def f(name):     print('hello', name)     time.sleep(1) if __name__ == '__main__':     p_lst = []     for i in range(5):         p = Process(target=f, args=('bob',))         p.start()         p_lst.append(p)         p.join()     # [p.join() for p in p_lst]     print('父进程在执行')`

## 多个进程同时运行，再谈join方法(2)

`import time from multiprocessing import Process def f(name):     print('hello', name)     time.sleep(1) if __name__ == '__main__':     p_lst = []     for i in range(5):         p = Process(target=f, args=('bob',))         p.start()         p_lst.append(p)     # [p.join() for p in p_lst]     print('父进程在执行')`

除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式

## 通过继承Process类开启进程

`import os from multiprocessing import Process class MyProcess(Process): def **init**(self,name): super().**init**() self.name=name def run(self): print(os.getpid()) print('%s 正在和女主播聊天' %[self.name](http://self.name)) p1=MyProcess('wupeiqi') p2=MyProcess('yuanhao') p3=MyProcess('nezha') p1.start() # start会自动调用run p2.start()

# p2.run()

p3.start() p1.join() p2.join() p3.join() print('主线程')`

进程之间的数据隔离问题

## 进程之间的数据隔离问题

`from multiprocessing import Process def work():     global n     n=0     print('子进程内: ',n) if __name__ == '__main__':     n = 100     p=Process(target=work)     p.start()     print('主进程内: ',n)`

# 守护进程

会随着主进程的结束而结束。

主进程创建守护进程

其一：守护进程会在主进程代码执行结束后就终止

其二：守护进程内无法再开启子进程,否则抛出异常：`AssertionError: daemonic processes are not allowed to have children`

注意：**进程之间是互相独立的，主进程代码运行结束，守护进程随即终止。**

## 守护进程的启动

`import os import time from multiprocessing import Process class Myprocess(Process):     def __init__(self,person):         super().__init__()         self.person = person     def run(self):         print(os.getpid(),self.name)         print('%s正在和女主播聊天' %self.person) p=Myprocess('哪吒') p.daemon=True # 一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行 p.start() time.sleep(10)  # 在sleep时查看进程id对应的进程ps -ef|grep id print('主')`

## 主进程代码执行结束守护进程立即结束

`from multiprocessing import Process def foo():     print(123)     time.sleep(1)     print("end123") def bar():     print(456)     time.sleep(3)     print("end456") p1=Process(target=foo) p2=Process(target=bar) p1.daemon=True p1.start() p2.start() time.sleep(0.1) print("main-------")  # 打印该行则主进程代码结束,则守护进程p1应该被终止.#可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止.`

# 多进程中的其他方法

## 进程对象的其他方法：terminate和is_alive

`from multiprocessing import Process import time import random class Myprocess(Process):     def __init__(self,person):         self.name=person         super().__init__()     def run(self):         print('%s正在和网红脸聊天' %self.name)         time.sleep(random.randrange(1,5))         print('%s还在和网红脸聊天' %self.name) p1=Myprocess('哪吒') p1.start() p1.terminate()#关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活 print(p1.is_alive()) #结果为True print('开始') print(p1.is_alive()) #结果为False`

## 进程对象的其他属性：pid和name

`class Myprocess(Process):     def __init__(self,person):         self.name=person   # name属性是Process中的属性，标示进程的名字         super().__init__()  # 执行父类的初始化方法会覆盖name属性         # self.name = person  # 在这里设置就可以修改进程名字了         # self.person = person  # 如果不想覆盖进程名，就修改属性名称就可以了     def run(self):         print('%s正在和网红脸聊天' %self.name)         # print('%s正在和网红脸聊天' %self.person)         time.sleep(random.randrange(1,5))         print('%s正在和网红脸聊天' %self.name)         # print('%s正在和网红脸聊天' %self.person) p1=Myprocess('哪吒') p1.start() print(p1.pid)    #可以查看子进程的进程id`




# 进程锁
# 进程锁

尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题：当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。

### 多进程抢占输出资源

`import os import time import random from multiprocessing import Process def work(n):     print('%s: %s is running' %(n,os.getpid()))     time.sleep(random.random())     print('%s:%s is done' %(n,os.getpid())) if __name__ == '__main__':     for i in range(3):         p=Process(target=work,args=(i,))         p.start()`

### 使用锁维护执行顺序

`# 由并发变成了串行,牺牲了运行效率,但避免了竞争 import os import time import random from multiprocessing import Process,Lock def work(lock,n):     lock.acquire()     print('%s: %s is running' % (n, os.getpid()))     time.sleep(random.random())     print('%s: %s is done' % (n, os.getpid()))     lock.release() if __name__ == '__main__':     lock=Lock()     for i in range(3):         p=Process(target=work,args=(lock,i))         p.start()`

上面这种情况虽然使用加锁的形式实现了顺序的执行，但是程序又重新变成串行了，这样确实会浪费了时间，却保证了数据的安全。

接下来，我们以模拟抢票为例，来看看数据安全的重要性。

### 多进程同时抢购余票

`# 文件db的内容为：{"count":1}

# 注意一定要用双引号，不然json无法识别

# 并发运行，效率高，但竞争写同一文件，数据写入错乱

from multiprocessing import Process,Lock import time,json,random def search(): dic=json.load(open('db')) print('剩余票数%s' %dic['count']) def get(): dic=json.load(open('db')) time.sleep(0.1)  # 模拟读数据的网络延迟 if dic['count'] >0: dic['count']-=1 time.sleep(0.2)  # 模拟写数据的网络延迟 json.dump(dic,open('db','w')) print('购票成功') def task(): search() get() if **name** == '**main**': for i in range(100):  # 模拟并发100个客户端抢票 p=Process(target=task) p.start()`

### 使用锁来保证数据安全

`# 文件db的内容为：{"count":5}

# 注意一定要用双引号，不然json无法识别

# 并发运行，效率高，但竞争写同一文件，数据写入错乱

from multiprocessing import Process,Lock import time,json,random def search(): dic=json.load(open('db')) print('剩余票数%s' %dic['count']) def get(): dic=json.load(open('db')) time.sleep(random.random())  # 模拟读数据的网络延迟 if dic['count'] >0: dic['count']-=1 time.sleep(random.random())  # 模拟写数据的网络延迟 json.dump(dic,open('db','w')) print('购票成功') else: print('购票失败') def task(lock): search() lock.acquire() get() lock.release() if **name** == '**main**': lock = Lock() for i in range(100):  # 模拟并发100个客户端抢票 p=Process(target=task,args=(lock,)) p.start()`

加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。

虽然可以用文件共享数据实现进程间通信，但问题是：

1. 效率低（共享数据基于文件，而文件是硬盘上的数据）
2. 需要自己加锁处理

因此我们最好找寻一种解决方案能够兼顾：

1. 效率高（多个进程共享一块内存的数据）
2. 帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。

队列和管道都是将数据存放于内存中，队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。

---

最后更新: 6 months ago


# 进程间通讯


# 进程间通信

IPC(Inter-Process Communication)

## 队列

### 概念介绍——multiprocess.Queue

创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。

`Queue([maxsize])`创建共享的进程队列。 参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。

底层队列使用管道和锁定实现。

### **方法介绍**

`Queue([maxsize])`：创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 Queue的实例q具有以下方法：

`q.get( [ block [ ,timeout ] ] )`：返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。

`q.get_nowait()` ：同`q.get(False)`方法。

`q.put(item [, block [,timeout ] ] )` ：将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。

`q.qsize()` ：返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。

`q.empty()` ：如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。

`q.full()` ：如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考`q.empty()`方法）。

### **其他方法(了解)**

`q.close()` ：关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在`get()`操作上，关闭生产者中的队列不会导致`get()`方法返回错误。

`q.cancel_join_thread()` ：不会再进程退出时自动连接后台线程。这可以防止`join_thread()`方法阻塞。

`q.join_thread()` ：连接队列的后台线程。此方法用于在调用`q.close()`方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用`q.cancel_join_thread()`方法可以禁止这种行为。

## 代码实例——multiprocess.Queue

### 单看队列用法

`''' multiprocessing模块支持进程间通信的两种主要形式:管道和队列 都是基于消息传递实现的,但是队列接口 ''' from multiprocessing import Queue q=Queue(3) #put ,get ,put_nowait,get_nowait,full,empty q.put(3) q.put(3) q.put(3)

# q.put(3)   # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。

```
       # 如果队列中的数据一直不被取走，程序就会永远停在这里。
```

try: q.put_nowait(3) # 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。 except: # 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。 print('队列已经满了')

# 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。

print(q.full()) #满了 print(q.get()) print(q.get()) print(q.get())

# print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。

try: q.get_nowait(3) # 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。 except: # 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。 print('队列已经空了') print(q.empty()) #空了`

上面这个例子还没有加入进程通信，只是先来看看队列为我们提供的方法，以及这些方法的使用和现象。

### 子进程发送数据给父进程

`import time from multiprocessing import Process, Queue def f(q):     q.put([time.asctime(), 'from Eva', 'hello'])  #调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。 if __name__ == '__main__':     q = Queue() #创建一个Queue对象     p = Process(target=f, args=(q,)) #创建一个进程     p.start()     print(q.get())     p.join()`

上面是一个queue的简单应用，使用队列q对象调用get函数来取得队列中最先进入的数据。 接下来看一个稍微复杂一些的例子：批量生产数据放入队列再批量获取结果。

### 批量生产数据放入队列再批量获取结果

`import os import time import multiprocessing

# 向queue中输入数据的函数

def inputQ(queue): info = str(os.getpid()) + '(put):' + str(time.asctime()) queue.put(info)

# 向queue中输出数据的函数

def outputQ(queue): info = queue.get() print ('%s%s%s'%(str(os.getpid()), '(get):',info))

# Main

if **name** == '**main**': multiprocessing.freeze_support() record1 = []   # store input processes record2 = []   # store output processes queue = multiprocessing.Queue(3) # 输入进程 for i in range(10): process = multiprocessing.Process(target=inputQ,args=(queue,)) process.start() record1.append(process) # 输出进程 for i in range(10): process = multiprocessing.Process(target=outputQ,args=(queue,)) process.start() record2.append(process) for p in record1: p.join() for p in record2: p.join()`

## 生产者消费者模型

在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。

在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。

生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

### 基于队列实现生产者消费者模型

`from multiprocessing import Process,Queue import time,random,os def consumer(q):     while True:         res=q.get()         time.sleep(random.randint(1,3))         print('%s 吃 %s' %(os.getpid(),res)) def producer(q):     for i in range(10):         time.sleep(random.randint(1,3))         res='包子%s' %i         q.put(res)         print('生产了 %s' %(os.getpid(),res)) if __name__ == '__main__':     q=Queue()     #生产者们:即厨师们     p1=Process(target=producer,args=(q,))     #消费者们:即吃货们     c1=Process(target=consumer,args=(q,))     #开始     p1.start()     c1.start()     print('主')`

此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。

解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环。

### 改良版——生产者消费者模型

`from multiprocessing import Process,Queue import time,random,os def consumer(q):     while True:         res=q.get()         if res is None:break #收到结束信号则结束         time.sleep(random.randint(1,3))         print('%s 吃 %s' %(os.getpid(),res)) def producer(q):     for i in range(10):         time.sleep(random.randint(1,3))         res='包子%s' %i         q.put(res)         print('生产了 %s' %(os.getpid(),res))     q.put(None) #发送结束信号 if __name__ == '__main__':     q=Queue()     #生产者们:即厨师们     p1=Process(target=producer,args=(q,))     #消费者们:即吃货们     c1=Process(target=consumer,args=(q,))     #开始     p1.start()     c1.start()     print('主')`

注意：**结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号。**

### 主进程在生产者生产完毕后发送结束信号None

`from multiprocessing import Process,Queue import time,random,os def consumer(q):     while True:         res=q.get()         if res is None:break #收到结束信号则结束         time.sleep(random.randint(1,3))         print('%s 吃 %s' %(os.getpid(),res)) def producer(q):     for i in range(2):         time.sleep(random.randint(1,3))         res='包子%s' %i         q.put(res)         print('生产了 %s' %(os.getpid(),res)) if __name__ == '__main__':     q=Queue()     #生产者们:即厨师们     p1=Process(target=producer,args=(q,))     #消费者们:即吃货们     c1=Process(target=consumer,args=(q,))     #开始     p1.start()     c1.start()     p1.join()     q.put(None) #发送结束信号     print('主')`

但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决

### 多个消费者的例子：有几个消费者就需要发送几次结束信号

`from multiprocessing import Process,Queue import time,random,os def consumer(q):     while True:         res=q.get()         if res is None:break #收到结束信号则结束         time.sleep(random.randint(1,3))         print('%s 吃 %s' %(os.getpid(),res)) def producer(name,q):     for i in range(2):         time.sleep(random.randint(1,3))         res='%s%s' %(name,i)         q.put(res)         print('生产了 %s' %(os.getpid(),res)) if __name__ == '__main__':     q=Queue()     #生产者们:即厨师们     p1=Process(target=producer,args=('包子',q))     p2=Process(target=producer,args=('骨头',q))     p3=Process(target=producer,args=('泔水',q))     #消费者们:即吃货们     c1=Process(target=consumer,args=(q,))     c2=Process(target=consumer,args=(q,))     #开始     p1.start()     p2.start()     p3.start()     c1.start()     p1.join() #必须保证生产者全部生产完毕,才应该发送结束信号     p2.join()     p3.join()     q.put(None) #有几个消费者就应该发送几次结束信号None     q.put(None) #发送结束信号     print('主')`

## JoinableQueue([maxsize])

创建可连接的共享进程队列。这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。

### 方法介绍

JoinableQueue的实例p除了与Queue对象相同的方法之外，还具有以下方法：

`q.task_done()`：使用者使用此方法发出信号，表示q.get()返回的项目已经被处理。如果调用此方法的次数大于从队列中删除的项目数量，将引发ValueError异常。

`q.join()`：生产者将使用此方法进行阻塞，直到队列中所有项目均被处理。阻塞将持续到为队列中的每个项目均调用q.task_done()方法为止。 下面的例子说明如何建立永远运行的进程，使用和处理队列上的项目。生产者将项目放入队列，并等待它们被处理。

### JoinableQueue队列实现消费之生产者模型

`from multiprocessing import Process,JoinableQueue import time,random,os def consumer(q):     while True:         res=q.get()         time.sleep(random.randint(1,3))         print('%s 吃 %s' %(os.getpid(),res))         q.task_done() #向q.join()发送一次信号,证明一个数据已经被取走了 def producer(name,q):     for i in range(10):         time.sleep(random.randint(1,3))         res='%s%s' %(name,i)         q.put(res)         print('生产了 %s' %(os.getpid(),res))     q.join() #生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理。 if __name__ == '__main__':     q=JoinableQueue()     #生产者们:即厨师们     p1=Process(target=producer,args=('包子',q))     p2=Process(target=producer,args=('骨头',q))     p3=Process(target=producer,args=('泔水',q))     #消费者们:即吃货们     c1=Process(target=consumer,args=(q,))     c2=Process(target=consumer,args=(q,))     c1.daemon=True     c2.daemon=True     #开始     p_l=[p1,p2,p3,c1,c2]     for p in p_l:         p.start()     p1.join()     p2.join()     p3.join()     print('主')      #主进程等--->p1,p2,p3等---->c1,c2     #p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据     #因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了。`

## 数据共享

展望未来，基于消息传递的并发编程是大势所趋

即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。

这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。

但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。

以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。

### Manager模块介绍

进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的。

虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此。

A manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies.

A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array.

### Manager例子

`from multiprocessing import Manager,Process,Lock def work(d,lock):     with lock:  # 不加锁而操作共享的数据,肯定会出现数据错乱         d['count']-=1 if __name__ == '__main__':     lock=Lock()     with Manager() as m:         dic=m.dict({'count':100})         p_l=[]         for i in range(100):             p=Process(target=work,args=(dic,lock))             p_l.append(p)             p.start()         for p in p_l:             p.join()         print(dic)`








